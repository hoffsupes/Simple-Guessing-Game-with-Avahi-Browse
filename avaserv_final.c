#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include "dns_sd.h"
#include <stdio.h>          
#include <string.h>         
#include <errno.h>          
#include <time.h>
#include <sys/time.h>       
#include <unistd.h>         
#include <arpa/inet.h>
#include <math.h>

#define MMX(A,B) ( (A > B) ? (A) : (B)) // Macro for maximum because max and min seem to be reserved keywords in C

float log_2(float k)                    // Calculates the log(base 2) of the function as: log_2(x) = loge(x) / loge(2);
{
    return ( (float) ( log(k) / log(2) ) );
}

int get_random_number(int mini, int maxi,int warez)     // Generates a random number between minimum value and maximum value, 
{                                                       // uses the portnumber (generated by the system) as seed
srand(warez);
return ( rand() % maxi + mini );
}

int get_number(char * kuchi,int i, int *f)              // Parses the number out of a string ensuring both a bounds check and filtering of any non-numerical values
{                                                       // ASSUMPTION: The string contained in *kuchi has an instance of "guess" in some form or mixture
    int NI;
    char c;
    
    kuchi = kuchi + strlen("guess");                    // traverse the pointer the whole length of guess, we're only interested in what comes after guess
    
    
    int ret = sscanf(kuchi,"%*[^0123456789]%d",&NI);   // sscanf lets us check for only numbers within this string and if there are any
    int ret2 = 1;

    for(char *cc = kuchi; (*cc) != '\0'; cc++ )         // check for any other clutter other than numbers within string kuchi
    {
        if( ( ((*cc) >= 'a') && ( (*cc) <= 'z' ) ) || (  ((*cc) >= 'A') && ( (*cc) <= 'Z' )  ))
        {
            ret2 = 0;
            break;
        }
    }
    
    
    if (ret == 0)                                       // CASE: guess written without a nunmber DISCARD resets f flag
    {
    char w[100];
    sprintf(w,"\n ??? \n");
    write(i,w,strlen(w)+1);      
    (*f) = 0;
    return 0;
    }

    if (ret2 == 0)                                      // CASE: guess has extra clutter NOT ALLOWED DISCARD resets f flag
    {
    char w[100];
    sprintf(w,"\n ??? \n");
    write(i,w,strlen(w)+1);      
    (*f) = 0;
    return 0;
    }
    
    if(NI > 100 || NI < 1)                              // CASE: Both number and guess present but NUMBER OUT OF RANGE DISCARD resets f flag
    {
    char w[100];
    sprintf(w,"\n ??? \n");
    write(i,w,strlen(w)+1);  
    (*f) = 0;
    return 0;
    }
    
    
    return NI;
}


void handle_client(int i, int port__NO, fd_set * masta)                     // handles the client connection and closes it accordingly
{
    char w[500],str[100];
    int set_flag = 0;
    char * cc = "guess";                                                    // Initialize
    
    int stup_flug = 1, guess_count = 0;                                     // stup_flug SET
    int random_no = get_random_number(1,100,port__NO);                      // get random number, notice how random port number used for random number
    
    sprintf(w,"\n Guess a number: \n");
    write(i,w,strlen(w) + 1);
              
    while(stup_flug)                                                        // while loop, stopped by stup_flug flag
    {
    bzero(str,100);                                 
    read(i,str,100);                                                        // Read string from the client
    
    for(char *ptr = str; *ptr!='\0'; ptr++) { *ptr = tolower(*ptr); }       // Convert all characters to lower, makes it easy to process
    char *puchi = strstr(str,cc);                                           // Find given substring "guess" if it exists in the complete string

    if(puchi!=NULL)
    {
        int f = 6,*ff;
        ff = &f;                                                            // Initialize handlers
        
        int no = get_number(puchi,i,ff);                                    // get a random no b/w 0 and 1
        
        if((*ff) != 0)                                                      // ff (called f flag in get_number) flag set PROCEED
        {
            
            if(no == random_no )                                            // CORRECT condition
            {
            bzero(w,500);
            sprintf(w,"\n CORRECT \n");
            write(i,w,strlen(w)+1); 
            guess_count++;
            stup_flug = 0;                                                  // stup_flug RESET, WHILE LOOP ENDS
            }
            
            else if(no < random_no)                                         // GREATER condition
            {
            bzero(w,500);
            sprintf(w,"\n GREATER \n");
            guess_count++;
            write(i,w,strlen(w)+1);    
            }
            
            else                                                            // SMALLER condition
            {
            bzero(w,500);
            sprintf(w,"\n SMALLER \n");
            guess_count++;
            write(i,w,strlen(w)+1);                    
            }
                      
            
            
            
        }
        
    }

    else                                                                    // guess is not present in the string at all unknown input ???
    {
    bzero(w,500);
    sprintf(w,"\n ??? \n");
    write(i,w,strlen(w)+1);
    }

        
    }

    if( guess_count < (log_2(100) - 1) )                                    // GREAT GUESSING
    {
    bzero(w,500);
    sprintf(w,"\n GREAT GUESSING \n");
    write(i,w,strlen(w)+1);
    }
    else if(guess_count > (log_2(100) + 1))                                 // BETTER LUCK NEXT TIME
    {
    bzero(w,500);
    sprintf(w,"\n BETTER LUCK NEXT TIME \n");
    write(i,w,strlen(w)+1);
    }
    else                                                                    // MEDIOCRE
    {
    bzero(w,500);
    sprintf(w,"\n AVERAGE \n");
    write(i,w,strlen(w)+1);        
    }
    
    close(i);
    FD_CLR(i,masta);       // closes connection and clears file descriptor of socket from the master (duplicate) file descriptor set
        
}

                
static void RegstCallback(DNSServiceRef serv, DNSServiceFlags all_DNS_flags,  DNSServiceErrorType EC,  const char * nomme, const char * type, const char * domain, void * context)         // Callback function
{
#pragma unused(flags)
#pragma unused(context)
        
            
if (EC != kDNSServiceErr_NoError)
{
fprintf(stderr, "Error Code received::: %d\n", EC);
}
else
{
printf(" NAME:: %s TYPE:: %s DOMAIN:: %s \n", nomme, type, domain);
}
    
}

static DNSServiceErrorType Run_Avahi_Server()                   // Runs the server
{
    DNSServiceErrorType error;
    DNSServiceErrorType err;              
    DNSServiceRef serviceRef;                       // error ans serviceref objects defined

    char str[100];
    int listn_file_descp;
    int on = 1;
    
    struct sockaddr_in servaddr;                                            // sockaddr_in defined

    listn_file_descp = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                  // listening socket created
    setsockopt(listn_file_descp, SOL_SOCKET, SO_REUSEADDR, (char*)&on, sizeof(int));
    bzero( &servaddr, sizeof(servaddr));

    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htons(INADDR_ANY);
    servaddr.sin_port = htons(0);                                           // socket address structure initialized
 
    bind(listn_file_descp, (struct sockaddr_in *) &servaddr, sizeof(servaddr));    // bind the socket
    
    listen(listn_file_descp, 10);
    int s_len = sizeof(servaddr);
    
    getsockname(listn_file_descp,&servaddr,&(s_len));                              // current object socket is bound to      
    
    error = DNSServiceRegister(&serviceRef,0,0," dassg ","_gtn._tcp","local",NULL,servaddr.sin_port,0,NULL,RegstCallback,NULL); // advertising the service
    
    int dns_file_descp = DNSServiceRefSockFD(serviceRef);
    int nfds = dns_file_descp + 1;
    int new, max_file_descp;
    
    fd_set fdset, masta;
    
    FD_ZERO(&fdset);
    FD_ZERO(&masta);            // file descriptor sets for select() call made ready by setting to zero

    FD_SET(dns_file_descp,&masta);
    FD_SET(listn_file_descp,&masta);
    max_file_descp = MMX(dns_file_descp,listn_file_descp);                  
    
    int commu_file_descp = 0;            // file descp. used for accept
                
        while(1)                // infinite loop
        {
            memcpy(&fdset,&masta,sizeof(masta));
            
            int ret = select(max_file_descp+1,&fdset,(fd_set*)NULL, (fd_set*)NULL,0);
            
            for(int i = 0; i <=max_file_descp && ret > 0; i++ )
            {
                
                if( FD_ISSET(i,&fdset) )
                {
                    ret--;
                    
                    if(i == dns_file_descp)                     // handle zeroconf
                    {
                        err = DNSServiceProcessResult(serviceRef);
                    
                        if(err)
                        {
                            printf("\nError exiting!!\n");
                            exit(1);
                        }
                    
                    }
                    else if(i == listn_file_descp)             // something found on the listening socket
                    {
                        commu_file_descp = accept(listn_file_descp, (struct sockaddr_in *) NULL,(struct sockaddr_in *) NULL );            // accept gives new port where this new client is found
                            
                            if(commu_file_descp == -1)
                            {
                                printf("\n Error due to accept fail!! \n");  
                         
                            }
                            
                            FD_SET(commu_file_descp,&masta);         // added to master file descriptor
                            
                            if(max_file_descp < commu_file_descp )            // if max file descriptor lesser than commu_file_descp then set to it
                            {
                                max_file_descp = commu_file_descp;
                            }
                        
                    }
                    
                    else                    // a client fd, play game with client (single client server so one user at a time)
                    {
                    
                        handle_client(i,servaddr.sin_port,&masta);
                        
                    }
       
                }
            }
           
        }    
        
        DNSServiceRefDeallocate(serviceRef);                // deallocate serviceRef
        
return error; 
        
}
        
int main()
{    
    DNSServiceErrorType error = Run_Avahi_Server();
    return 1;
}
